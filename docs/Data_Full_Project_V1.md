# تحلیل فنی و استخراج نیازمندی‌ها از User Journey

## فاز ۱: نصب و هسته اصلی برنامه (نیازمندی‌های مشترک)

### نیازمندی فنی:

#### بسته نصب یکپارچه (Single Installer):
وظایف اینستالر:
- ایجاد یک فایل setup.exe واحد
- نصب اپلیکیشن اصلی (که با PyInstaller ساخته شده) در C:\Program Files\Tiktrue
- نصب و راه‌اندازی یک سرویس ویندوز به نام TiktrueWorkerService - این سرویس مسئول اجرای منطق model_node.py در پس‌زمینه است
- ایجاد میان‌بر در دسکتاپ و منوی استارت که به اپلیکیشن رابط کاربری اشاره دارد
- مدیریت مجوزها (Permissions) برای نصب سرویس و نوشتن در پوشه‌های سیستمی

#### اپلیکیشن مرکزی با معماری دو بخشی:
تکنولوژی: پایتون
باید دو نقطه ورود اصلی (Entry Point) داشته باشیم که در بسته نهایی قرار می‌گیرند:
- service_runner.py: برای اجرا به عنوان سرویس پس‌زمینه. این اسکریپت، سرور model_node.py را در یک نخ (Thread) جداگانه راه‌اندازی می‌کند
- main_app.py: برای اجرای رابط کاربری گرافیکی (GUI) که کاربر با آن تعامل می‌کند

#### امنیت کد منبع:
تکنولوژی: PyInstaller برای تبدیل کد به بایت‌کد و بسته‌بندی، و ابزاری مانند PyArmor برای رمزنگاری و مبهم‌سازی نهایی کدها قبل از بسته‌بندی. این مرحله در انتهای فرآیند توسعه اعمال خواهد شد.

## فاز ۲: اولین اجرا و مدیریت شبکه

### نیازمندی فنی:

#### رابط کاربری اولیه (First Run UI):
تکنولوژی: استفاده از یک فریمورک GUI مانند Gradio, PyQt/PySide - باید بروز و حرفه‌ای باشد
- main_app.py باید تشخیص دهد که آیا فایل کانفیگ اصلی برنامه وجود دارد یا نه
- اگر هیچ شبکه‌ای تعریف نشده باشد، باید یک صفحه خوشامدگویی با دکمه‌های واضح "ایجاد شبکه جدید" و "پیوستن به شبکه" نمایش دهد

#### ماژول مدیریت شبکه (network_manager.py):
ایجاد یک کلاس یا ماژول اختصاصی برای تمام عملیات مربوط به شبکه.
- تابع create_network():
  - یک فایل network_config_...json جدید می‌سازد
  - model_id و network_id را در آن ذخیره می‌کند
  - اطلاعات پایه مانند model_chain_order را بر اساس model_id از یک تمپلیت داخلی می‌خواند و در فایل کانفیگ قرار می‌دهد
- تابع discover_networks():
  - از مکانیزم UDP Broadcast یا Multicast در شبکه محلی (LAN) برای یافتن سایر گره‌هایی که سرویس Worker تیک‌تورو روی آنها فعال است، استفاده می‌کند
  - گره‌های فعال پاسخ می‌دهند و لیستی از شبکه‌هایی که در آنها عضو هستند را برمی‌گردانند
  - این تابع، لیست شبکه‌های قابل پیوستن را برای نمایش در UI برمی‌گرداند
- تابع join_network():
  - وقتی کاربر شبکه‌ای را برای پیوستن انتخاب می‌کند، این تابع باید بتواند فایل کانفیگ آن شبکه را از گره مبدا درخواست کرده و به صورت محلی ذخیره کند
- تابع list_joined_networks():
  - تمام فایل‌های network_config_...json ذخیره شده به صورت محلی را لیست کرده و برای نمایش در UI آماده می‌کند

#### ماژول دانلود مدل (model_downloader.py):
یک ماژول مسئول برای دانلود فایل‌های مدل از یک سرور مرکزی (وب سرور).
- تابع download_model_blocks():
  - بر اساس model_id, لیست فایل‌های مورد نیاز (فقط نسخه‌های بهینه و رمزنگاری شده) را از یک manifest.json روی سرور می‌خواند
  - فایل‌ها را دانلود کرده و در مسیر استاندارد assets/models/{model_id}/ ذخیره می‌کند
  - یک progress_callback را فراخوانی می‌کند تا UI بتواند نوار پیشرفت را به‌روز کند
  - این ماژول باید قابلیت ادامه دانلود (Resumable Download) را در صورت قطع شدن ارتباط داشته باشد.

## فاز ۳: استفاده روزمره و چت

### نیازمندی فنی:

#### رابط کاربری چت:
یک بخش در main_app.py که رابط چت را پیاده‌سازی می‌کند.
نیازمندی‌ها:
- نمایش تاریخچه مکالمه
- یک کادر ورود متن و دکمه ارسال
- نمایش پاسخ مدل به صورت جریان (Streaming) یا کلمه به کلمه برای تجربه کاربری بهتر
- نمایش شبکه‌ای که به آن متصل است

#### کلاینت WebSocket یکپارچه:
یک ماژول (api_client.py) که منطق ارتباط با سرور model_node.py از طریق WebSocket را در خود کپسوله می‌کند. این دقیقاً همان کاری است که chatbot_interface.py فعلی انجام می‌دهد. البته منطق‌های مهم دیگری هم دارد که باید پیاده‌سازی شود.
- باید بتواند درخواست‌ها را با ساختار JSON استاندارد شده (شامل input_ids, attention_mask و...) ارسال کند

#### قابلیت ذخیره و بازیابی مکالمه (Persistence):
تکنولوژی: استفاده از numpy.savez_compressed برای ذخیره‌سازی بهینه
نیازمندی‌ها در session_management.py:
- پیاده‌سازی متدهای save_to_disk(filepath) و load_from_disk(filepath) در کلاس SessionPagedKVCache
نیازمندی‌ها در api_client.py:
- پس از هر پاسخ موفق از مدل، به صورت خودکار متد save_to_disk را برای آن session فراخوانی کند
- در زمان شروع برنامه، پوشه sessions را اسکن کرده، مکالمات ذخیره شده را لیست کند و به کاربر اجازه دهد با یک کلیک آنها را بارگذاری و ادامه دهد

## فاز ۴: مدیریت چند شبکه

### نیازمندی فنی:

#### سرویس Worker چند-شبکه‌ای:
اصلاح service_runner.py:
- سرویس پس‌زمینه باید به جای راه‌اندازی یک سرور روی یک پورت ثابت، تمام فایل‌های network_config_...json را بخواند و برای هر شبکه یک سرور WebSocket جداگانه روی پورت مشخص شده در آن کانفیگ راه‌اندازی کند. این کار را می‌توان با asyncio.gather انجام داد
- هر درخواست ورودی باید مشخص کند که متعلق به کدام network_id است تا منطق درست مدل بارگذاری شود. (این مورد باید در پروتکل ارتباطی WebSocket ما تعریف شود)

#### رابط کاربری با قابلیت انتخاب شبکه:
- در UI اصلی و همچنین در رابط چت، باید یک منوی کشویی (Dropdown) وجود داشته باشد که تمام شبکه‌هایی که کاربر در آنها عضو است را لیست کند (list_joined_networks())
- انتخاب یک شبکه در این منو، مشخص می‌کند که درخواست‌های چت به کدام سرور (و پورت) ارسال شوند

## فاز ۵: مدیریت خرابی و بازیابی (Error Handling & Recovery)

### نیازمندی فنی:

#### سیستم نظارت بر ورکرها (health_monitor.py):
- تابع monitor_worker_health():
  - بررسی مداوم سلامت تمام ورکرها از طریق heartbeat ping
  - تشخیص ورکرهای غیرفعال یا از دسترس خارج شده
  - ارسال هشدار به ادمین در صورت خرابی ورکر
- تابع redistribute_blocks():
  - در صورت خرابی ورکر، بلاک‌های آن را به ورکرهای پشتیبان یا سایر ورکرهای فعال منتقل کند
  - به‌روزرسانی خودکار Network_config پس از توزیع مجدد

#### مکانیزم فیل‌اور (failover_manager.py):
- تابع activate_backup_worker():
  - فعال‌سازی فوری ورکرهای پشتیبان در صورت خرابی ورکر اصلی
  - انتقال سریع بار کاری به ورکر پشتیبان
- تابع graceful_degradation():
  - کاهش تدریجی کیفیت سرویس در صورت کمبود منابع
  - ادامه ارائه سرویس با کارایی کمتر تا بازگشت ورکرها

## فاز ۶: امنیت و احراز هویت (Security Framework)

### نیازمندی فنی:

#### سیستم احراز هویت (auth_manager.py):
- تابع generate_node_certificate():
  - تولید گواهینامه منحصربه‌فرد برای هر نود
  - استفاده از RSA یا ECDSA برای امضای دیجیتال
- تابع verify_node_identity():
  - تأیید اعتبار نودها قبل از اجازه اتصال به شبکه
  - مکانیزم Challenge-Response برای جلوگیری از حملات Man-in-the-Middle

#### رمزنگاری ارتباطات (crypto_layer.py):
- پروتکل TLS/SSL:
  - رمزنگاری تمام ارتباطات WebSocket با TLS 1.3
  - استفاده از Perfect Forward Secrecy (PFS)
- تابع encrypt_block_transfer():
  - رمزنگاری انتقال بلاک‌های مدل بین نودها
  - استفاده از AES-256-GCM برای رمزنگاری سریع

#### مدیریت دسترسی (access_control.py):
- تابع manage_worker_permissions():
  - تعریف سطوح دسترسی مختلف (Admin, Worker, Backup)
  - کنترل دسترسی بر اساس نقش کاربر

## فاز ۷: پروتکل ارتباطی و مانیتورینگ

### نیازمندی فنی:

#### مشخصات پروتکل WebSocket (protocol_spec.py):
```json
// ساختار استاندارد درخواست
{
  "message_type": "inference_request",
  "network_id": "network_001",
  "session_id": "session_abc123",
  "timestamp": 1642784400,
  "payload": {
    "input_ids": [101, 2023, 2003, ...],
    "attention_mask": [1, 1, 1, ...],
    "max_length": 512
  }
}

// ساختار استاندارد پاسخ
{
  "message_type": "inference_response", 
  "network_id": "network_001",
  "session_id": "session_abc123",
  "status": "success|error|processing",
  "payload": {
    "output_tokens": [102, 2054, 2003, ...],
    "processing_time": 1.24,
    "worker_id": "worker_node_3"
  }
}
```

#### سیستم لاگ‌گیری و نظارت (monitoring_system.py):
- تابع log_system_events():
  - ثبت تمام رویدادهای مهم سیستم
  - نظارت بر عملکرد و میزان استفاده از منابع
- تابع generate_performance_reports():
  - تولید گزارش‌های عملکرد دوره‌ای
  - تحلیل بهره‌وری و بهینه‌سازی منابع

## فاز ۸: مدیریت پیکربندی پیشرفته

### نیازمندی فنی:

#### همگام‌سازی کانفیگ (config_sync.py):
- تابع broadcast_config_updates():
  - ارسال به‌روزرسانی‌های کانفیگ به تمام نودها
  - تأیید دریافت و اعمال تغییرات
- تابع handle_config_conflicts():
  - حل تعارضات کانفیگ در صورت به‌روزرسانی همزمان
  - الگوریتم Consensus برای تصمیم‌گیری نهایی

#### بهینه‌سازی منابع (resource_optimizer.py):
- تابع analyze_workload_patterns():
  - تحلیل الگوهای استفاده از منابع
  - پیشنهاد بهینه‌سازی توزیع بلاک‌ها
- تابع dynamic_load_balancing():
  - توزیع پویا بار کاری بر اساس ظرفیت نودها
  - انطباق خودکار با تغییر شرایط شبکه

## خلاصه کلی سیستم

### 1. 🎯 دانلود و نصب
- کاربر ابتدا پکیج نصب سبک را از سایت ما دریافت می‌کند.
- این پکیج شامل موارد زیر است:
  - ✅ موتور اجرایی (Runtime)
  - ✅ وابستگی‌های پایه (Dependencies)
  - ⛔ فاقد بلاک‌ها (Blocks) یا فایل‌های مدل
- این پکیج روی تمام سیستم‌هایی که قرار است ورکر (Worker) یا ادمین (Admin) باشند نصب می‌شود.
- پس از نصب، سرویس در بک‌گراند سیستم فعال باقی می‌ماند و منتظر سیگنال از کنترلر می‌ماند.
- سپس از کاربر نام شبکه (Network Name) گرفته می‌شود. یا باید بسازد یا اگه ساخته شده است می‌تواند آن را انتخاب کند و به آن جوین شود.

### 2. 🧠 ساخت Distributed Computing Platform
- یکی از سیستم‌ها (Control Node) توسط کاربر به‌عنوان مرکز مدیریت پلتفرم (ادمین) انتخاب می‌شود که داشبورد مدیریت منابع هر سیستمی که به آن متصل است را می‌بیند و مدیریت می‌کند.
- نرم‌افزار ما روی این سیستم اجرا شده و فرآیند زیر را آغاز می‌کند:
  - 🔍 اسکن شبکه داخلی (LAN) برای شناسایی تمام سیستم‌هایی که پکیج ورکر روی آن‌ها نصب شده است
  - 🤝 پس از تأیید لیست شناسایی‌شده توسط کاربر، به مرحله بعد می‌رویم

### 3. 📊 شناسایی و تخصیص منابع ورکرها
- برای هر سیستم شناسایی‌شده، نرم‌افزار:
  - 🔎 میزان منابع سخت‌افزاری (CPU, RAM, Disk) را بررسی می‌کند
  - ⚙️ به کاربر اجازه می‌دهد تا تعیین کند چه مقدار از هر منبع از هر ورکر به پلتفرم اختصاص یابد

### 4. 🧱 ساخت فایل Network_config و تخصیص بلاک‌ها
- بر اساس منابع تخصیص‌یافته به هر سیستم، یک فایل پیکربندی با نام Network_config ساخته می‌شود.
- این فایل مشخص می‌کند که هر ورکر چند بلاک می‌تواند مدیریت کند:
  - مثلاً: ورکر A → 3 بلاک، ورکر B → 10 بلاک
- این کانفیگ برای همه ورکرها ارسال و ذخیره می‌شود.

### 5. 📦 دانلود و توزیع بلاک‌های مدل
- سیستمی که نقش کنترل دارد (Admin)، تمامی بلاک‌های مربوط به مدل انتخاب‌شده را:
  - 📥 دانلود می‌کند
  - 📤 سپس از طریق شبکه، بلاک‌های مربوط به هر ورکر را بر اساس Network_config ارسال می‌کند

### 6. 🔄 مدیریت تغییر در تعداد ورکرها
- در صورت اضافه یا حذف ورکر از شبکه:
  - فایل Network_config به‌صورت داینامیک آپدیت می‌شود
  - بلاک‌ها مجدداً بین سیستم‌های موجود توزیع مجدد می‌شوند

### 🧩 نتیجه نهایی:
- یک پلتفرم محلی و شخصی برای محاسبات توزیع‌شده با ویژگی‌های زیر:
  - بدون نیاز به اینترنت یا فضای ابری
  - قابل تنظیم توسط کاربر
  - منعطف در برابر تغییر منابع و نودها
  - مقاوم در برابر خرابی‌ها
  - امن و قابل اعتماد